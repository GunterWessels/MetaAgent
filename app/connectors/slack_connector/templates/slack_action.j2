"""
Slack Action Module for {{ plan.intent }} Intent

This module was auto-generated by the Meta-Agent to perform Slack actions related to the {{ plan.intent }} intent.
It provides functions for executing specific actions on Slack based on the execution plan.

Generated for Goal: {{ plan.goal_id }}
Created at: {{ plan.created_at }}
"""

import json
import logging
import os
import time
from typing import Dict, Any, Optional, List, Union, Callable, Awaitable
from datetime import datetime

import slack_sdk
from slack_sdk import WebClient
from slack_sdk.errors import SlackApiError
from slack_sdk.web.async_client import AsyncWebClient

# Set up logging
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

# Constants
INTENT = "{{ plan.intent }}"
GOAL_ID = "{{ plan.goal_id }}"
STEP_ID = "{{ step.id }}"
ACTION_TYPE = "{{ step.action_type }}"

# Configuration
SLACK_TOKEN = os.environ.get("SLACK_API_TOKEN", "{{ config.slack_api_token }}")
{% if parameters.get("channel") %}
TARGET_CHANNEL = "{{ parameters.get('channel') }}"
{% else %}
TARGET_CHANNEL = os.environ.get("SLACK_CHANNEL", "general")
{% endif %}

class SlackAction:
    """
    Slack Action executor for {{ plan.intent }} intent.
    
    This class provides methods for executing various Slack actions
    related to the {{ plan.intent }} intent.
    """
    
    def __init__(self, token: str = SLACK_TOKEN):
        """
        Initialize the Slack Action executor.
        
        Args:
            token: Slack API token
        """
        self.token = token
        self.client = WebClient(token=token)
        self.async_client = AsyncWebClient(token=token)
        
        logger.info(f"Initialized Slack Action executor for {INTENT} intent")
    
    async def verify_connection(self) -> bool:
        """
        Verify the connection to Slack.
        
        Returns:
            bool: True if connected, False otherwise
        """
        try:
            response = await self.async_client.auth_test()
            logger.info(f"Connected to Slack as {response['user']} in workspace {response['team']}")
            return True
        except SlackApiError as e:
            logger.error(f"Failed to connect to Slack: {e}")
            return False
    
    async def execute_action(self, action_params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute the appropriate Slack action based on the intent.
        
        Args:
            action_params: Parameters for the action
            
        Returns:
            Dict[str, Any]: Result of the action
        """
        # Verify connection first
        if not await self.verify_connection():
            return {
                "success": False,
                "error": "Failed to connect to Slack",
                "timestamp": datetime.utcnow().isoformat()
            }
        
        try:
            {% if plan.intent == "create_task" %}
            return await self.create_task(action_params)
            {% elif plan.intent == "schedule_meeting" %}
            return await self.schedule_meeting(action_params)
            {% elif plan.intent == "find_information" %}
            return await self.find_information(action_params)
            {% elif plan.intent == "send_message" %}
            return await self.send_message(action_params)
            {% elif plan.intent == "update_status" %}
            return await self.update_status(action_params)
            {% else %}
            return await self.execute_generic_action(action_params)
            {% endif %}
        except Exception as e:
            logger.exception(f"Error executing Slack action: {e}")
            return {
                "success": False,
                "error": str(e),
                "timestamp": datetime.utcnow().isoformat()
            }
    
    {% if plan.intent == "create_task" %}
    async def create_task(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Create a task in Slack.
        
        Args:
            params: Task parameters
            
        Returns:
            Dict[str, Any]: Result of the action
        """
        try:
            # Extract parameters
            title = params.get("topic", params.get("title", "New Task"))
            description = params.get("description", "")
            due_date = params.get("date", "")
            priority = params.get("priority", "medium")
            assignee = params.get("person", "")
            channel = params.get("channel", TARGET_CHANNEL)
            
            # Create a message with task details
            blocks = [
                {
                    "type": "header",
                    "text": {
                        "type": "plain_text",
                        "text": f"Task: {title}",
                        "emoji": True
                    }
                },
                {
                    "type": "section",
                    "fields": [
                        {
                            "type": "mrkdwn",
                            "text": f"*Due Date:*\n{due_date or 'Not specified'}"
                        },
                        {
                            "type": "mrkdwn",
                            "text": f"*Priority:*\n{priority}"
                        }
                    ]
                }
            ]
            
            if description:
                blocks.append({
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": f"*Description:*\n{description}"
                    }
                })
            
            if assignee:
                blocks.append({
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": f"*Assigned to:*\n<@{assignee}>"
                    }
                })
            
            # Add action buttons
            blocks.append({
                "type": "actions",
                "elements": [
                    {
                        "type": "button",
                        "text": {
                            "type": "plain_text",
                            "text": "Complete",
                            "emoji": True
                        },
                        "style": "primary",
                        "value": "complete",
                        "action_id": "task_complete"
                    },
                    {
                        "type": "button",
                        "text": {
                            "type": "plain_text",
                            "text": "Reassign",
                            "emoji": True
                        },
                        "value": "reassign",
                        "action_id": "task_reassign"
                    }
                ]
            })
            
            # Send the message
            response = await self.async_client.chat_postMessage(
                channel=channel,
                text=f"New Task: {title}",
                blocks=blocks
            )
            
            # Create a reminder if due date is provided
            reminder = None
            if due_date:
                try:
                    reminder_response = await self.async_client.reminders_add(
                        text=f"Task due: {title}",
                        time=due_date,
                        user="me" if not assignee else assignee
                    )
                    reminder = reminder_response.get("reminder")
                except SlackApiError as e:
                    logger.warning(f"Failed to create reminder: {e}")
            
            return {
                "success": True,
                "task": {
                    "title": title,
                    "description": description,
                    "due_date": due_date,
                    "priority": priority,
                    "assignee": assignee,
                    "channel": channel,
                    "message_ts": response["ts"],
                    "reminder": reminder
                },
                "timestamp": datetime.utcnow().isoformat()
            }
        except SlackApiError as e:
            logger.error(f"Slack API error: {e}")
            return {
                "success": False,
                "error": f"Slack API error: {e.response['error']}",
                "timestamp": datetime.utcnow().isoformat()
            }
        except Exception as e:
            logger.exception(f"Error creating task: {e}")
            return {
                "success": False,
                "error": str(e),
                "timestamp": datetime.utcnow().isoformat()
            }
    {% elif plan.intent == "schedule_meeting" %}
    async def schedule_meeting(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Schedule a meeting and announce it in Slack.
        
        Args:
            params: Meeting parameters
            
        Returns:
            Dict[str, Any]: Result of the action
        """
        try:
            # Extract parameters
            title = params.get("topic", params.get("title", "New Meeting"))
            date = params.get("date", "")
            time = params.get("time", "")
            duration = params.get("duration", "60 minutes")
            location = params.get("location", "")
            description = params.get("description", "")
            attendees = params.get("person", params.get("attendees", []))
            channel = params.get("channel", TARGET_CHANNEL)
            
            # Format attendees if it's a string
            if isinstance(attendees, str):
                attendees = [attendee.strip() for attendee in attendees.split(",")]
            
            # Format date and time
            datetime_str = f"{date} {time}".strip()
            
            # Create a message with meeting details
            blocks = [
                {
                    "type": "header",
                    "text": {
                        "type": "plain_text",
                        "text": f"Meeting: {title}",
                        "emoji": True
                    }
                },
                {
                    "type": "section",
                    "fields": [
                        {
                            "type": "mrkdwn",
                            "text": f"*When:*\n{datetime_str or 'Not specified'}"
                        },
                        {
                            "type": "mrkdwn",
                            "text": f"*Duration:*\n{duration}"
                        }
                    ]
                }
            ]
            
            if location:
                blocks.append({
                    "type": "section",
                    "fields": [
                        {
                            "type": "mrkdwn",
                            "text": f"*Location:*\n{location}"
                        }
                    ]
                })
            
            if description:
                blocks.append({
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": f"*Agenda:*\n{description}"
                    }
                })
            
            if attendees:
                attendee_text = ", ".join([f"<@{attendee}>" for attendee in attendees])
                blocks.append({
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": f"*Attendees:*\n{attendee_text}"
                    }
                })
            
            # Add action buttons
            blocks.append({
                "type": "actions",
                "elements": [
                    {
                        "type": "button",
                        "text": {
                            "type": "plain_text",
                            "text": "Accept",
                            "emoji": True
                        },
                        "style": "primary",
                        "value": "accept",
                        "action_id": "meeting_accept"
                    },
                    {
                        "type": "button",
                        "text": {
                            "type": "plain_text",
                            "text": "Decline",
                            "emoji": True
                        },
                        "style": "danger",
                        "value": "decline",
                        "action_id": "meeting_decline"
                    },
                    {
                        "type": "button",
                        "text": {
                            "type": "plain_text",
                            "text": "Propose New Time",
                            "emoji": True
                        },
                        "value": "propose",
                        "action_id": "meeting_propose"
                    }
                ]
            })
            
            # Send the message
            response = await self.async_client.chat_postMessage(
                channel=channel,
                text=f"Meeting: {title} on {datetime_str}",
                blocks=blocks
            )
            
            # Create a reminder if date is provided
            reminder = None
            if date:
                try:
                    reminder_text = f"Meeting: {title}"
                    if time:
                        reminder_text += f" at {time}"
                    
                    reminder_response = await self.async_client.reminders_add(
                        text=reminder_text,
                        time=datetime_str if time else date,
                        user="me"
                    )
                    reminder = reminder_response.get("reminder")
                except SlackApiError as e:
                    logger.warning(f"Failed to create reminder: {e}")
            
            return {
                "success": True,
                "meeting": {
                    "title": title,
                    "date": date,
                    "time": time,
                    "duration": duration,
                    "location": location,
                    "description": description,
                    "attendees": attendees,
                    "channel": channel,
                    "message_ts": response["ts"],
                    "reminder": reminder
                },
                "timestamp": datetime.utcnow().isoformat()
            }
        except SlackApiError as e:
            logger.error(f"Slack API error: {e}")
            return {
                "success": False,
                "error": f"Slack API error: {e.response['error']}",
                "timestamp": datetime.utcnow().isoformat()
            }
        except Exception as e:
            logger.exception(f"Error scheduling meeting: {e}")
            return {
                "success": False,
                "error": str(e),
                "timestamp": datetime.utcnow().isoformat()
            }
    {% elif plan.intent == "find_information" %}
    async def find_information(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Search for information in Slack.
        
        Args:
            params: Search parameters
            
        Returns:
            Dict[str, Any]: Result of the action
        """
        try:
            # Extract parameters
            query = params.get("topic", params.get("query", ""))
            channel = params.get("channel", "")
            time_range = params.get("time_range", "")
            from_person = params.get("from_person", "")
            result_channel = params.get("result_channel", TARGET_CHANNEL)
            
            # Build search query
            search_query = query
            if channel:
                search_query += f" in:{channel}"
            if from_person:
                search_query += f" from:{from_person}"
            if time_range:
                search_query += f" during:{time_range}"
            
            # Perform the search
            search_response = await self.async_client.search_messages(
                query=search_query,
                count=10,
                sort="timestamp"
            )
            
            # Extract search results
            total = search_response["messages"].get("total", {}).get("value", 0)
            matches = search_response["messages"].get("matches", [])
            
            # Format results for display
            results_text = f"Found {total} results for query: *{query}*\n\n"
            
            blocks = [
                {
                    "type": "header",
                    "text": {
                        "type": "plain_text",
                        "text": f"Search Results: {query}",
                        "emoji": True
                    }
                },
                {
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": f"Found {total} results"
                    }
                }
            ]
            
            # Add the top results
            for i, match in enumerate(matches[:5], 1):
                permalink = match.get("permalink", "")
                text = match.get("text", "")
                channel_name = match.get("channel", {}).get("name", "unknown")
                username = match.get("username", match.get("user", "unknown"))
                ts = match.get("ts", "")
                
                # Convert timestamp to readable date
                date_str = "unknown date"
                if ts:
                    try:
                        date_obj = datetime.fromtimestamp(float(ts))
                        date_str = date_obj.strftime("%Y-%m-%d %H:%M:%S")
                    except (ValueError, TypeError):
                        pass
                
                blocks.append({
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": f"*{i}. Message in #{channel_name} by {username} on {date_str}*\n{text[:150]}{'...' if len(text) > 150 else ''}"
                    }
                })
                
                if permalink:
                    blocks.append({
                        "type": "actions",
                        "elements": [
                            {
                                "type": "button",
                                "text": {
                                    "type": "plain_text",
                                    "text": "View Message",
                                    "emoji": True
                                },
                                "url": permalink,
                                "action_id": f"view_message_{i}"
                            }
                        ]
                    })
            
            # Send the results
            response = await self.async_client.chat_postMessage(
                channel=result_channel,
                text=results_text,
                blocks=blocks
            )
            
            return {
                "success": True,
                "search": {
                    "query": query,
                    "total_results": total,
                    "matches": [
                        {
                            "text": match.get("text", ""),
                            "channel": match.get("channel", {}).get("name", ""),
                            "user": match.get("username", match.get("user", "")),
                            "timestamp": match.get("ts", ""),
                            "permalink": match.get("permalink", "")
                        }
                        for match in matches[:10]
                    ],
                    "result_channel": result_channel,
                    "message_ts": response["ts"]
                },
                "timestamp": datetime.utcnow().isoformat()
            }
        except SlackApiError as e:
            logger.error(f"Slack API error: {e}")
            return {
                "success": False,
                "error": f"Slack API error: {e.response['error']}",
                "timestamp": datetime.utcnow().isoformat()
            }
        except Exception as e:
            logger.exception(f"Error searching information: {e}")
            return {
                "success": False,
                "error": str(e),
                "timestamp": datetime.utcnow().isoformat()
            }
    {% elif plan.intent == "send_message" %}
    async def send_message(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Send a message in Slack.
        
        Args:
            params: Message parameters
            
        Returns:
            Dict[str, Any]: Result of the action
        """
        try:
            # Extract parameters
            recipient = params.get("person", params.get("recipient", ""))
            content = params.get("content", "")
            channel = params.get("channel", "")
            thread_ts = params.get("thread_ts", "")
            scheduled_time = params.get("scheduled_time", "")
            blocks = params.get("blocks", [])
            attachments = params.get("attachments", [])
            
            # Determine the channel to use
            target_channel = channel or recipient or TARGET_CHANNEL
            
            # If recipient is specified but not a channel, try to find the user's DM channel
            if recipient and not channel and not recipient.startswith(("C", "G", "D")):
                try:
                    # Look up user by email if it contains @ symbol
                    if "@" in recipient:
                        user_response = await self.async_client.users_lookupByEmail(email=recipient)
                        recipient = user_response["user"]["id"]
                    
                    # Open a DM channel with the user
                    dm_response = await self.async_client.conversations_open(users=recipient)
                    target_channel = dm_response["channel"]["id"]
                except SlackApiError as e:
                    logger.warning(f"Failed to open DM with {recipient}: {e}")
            
            # Send the message
            message_params = {
                "channel": target_channel,
                "text": content
            }
            
            if thread_ts:
                message_params["thread_ts"] = thread_ts
            
            if blocks:
                message_params["blocks"] = blocks
            
            if attachments:
                message_params["attachments"] = attachments
            
            # Handle scheduled messages
            if scheduled_time:
                try:
                    # Convert scheduled_time to Unix timestamp if it's not already
                    if not isinstance(scheduled_time, (int, float)):
                        # Try to parse as ISO format
                        try:
                            dt = datetime.fromisoformat(scheduled_time.replace('Z', '+00:00'))
                            scheduled_timestamp = int(dt.timestamp())
                        except (ValueError, AttributeError):
                            # Try to parse as natural language
                            import time
                            from dateutil import parser
                            dt = parser.parse(scheduled_time)
                            scheduled_timestamp = int(dt.timestamp())
                    else:
                        scheduled_timestamp = int(scheduled_time)
                    
                    # Schedule the message
                    schedule_response = await self.async_client.chat_scheduleMessage(
                        channel=target_channel,
                        text=content,
                        post_at=scheduled_timestamp,
                        blocks=blocks if blocks else None,
                        attachments=attachments if attachments else None
                    )
                    
                    return {
                        "success": True,
                        "message": {
                            "recipient": recipient,
                            "content": content,
                            "channel": target_channel,
                            "scheduled_time": scheduled_time,
                            "scheduled_timestamp": scheduled_timestamp,
                            "scheduled_message_id": schedule_response["scheduled_message_id"]
                        },
                        "timestamp": datetime.utcnow().isoformat()
                    }
                except Exception as e:
                    logger.warning(f"Failed to schedule message, sending immediately: {e}")
            
            # Send the message immediately
            response = await self.async_client.chat_postMessage(**message_params)
            
            return {
                "success": True,
                "message": {
                    "recipient": recipient,
                    "content": content,
                    "channel": target_channel,
                    "thread_ts": thread_ts,
                    "message_ts": response["ts"]
                },
                "timestamp": datetime.utcnow().isoformat()
            }
        except SlackApiError as e:
            logger.error(f"Slack API error: {e}")
            return {
                "success": False,
                "error": f"Slack API error: {e.response['error']}",
                "timestamp": datetime.utcnow().isoformat()
            }
        except Exception as e:
            logger.exception(f"Error sending message: {e}")
            return {
                "success": False,
                "error": str(e),
                "timestamp": datetime.utcnow().isoformat()
            }
    {% elif plan.intent == "update_status" %}
    async def update_status(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Update status of an item in Slack.
        
        Args:
            params: Status update parameters
            
        Returns:
            Dict[str, Any]: Result of the action
        """
        try:
            # Extract parameters
            topic = params.get("topic", "")
            status = params.get("status", "")
            comment = params.get("comment", "")
            channel = params.get("channel", TARGET_CHANNEL)
            notify_person = params.get("notify_person", "")
            
            # Create a message with status update
            blocks = [
                {
                    "type": "header",
                    "text": {
                        "type": "plain_text",
                        "text": f"Status Update: {topic}",
                        "emoji": True
                    }
                },
                {
                    "type": "section",
                    "fields": [
                        {
                            "type": "mrkdwn",
                            "text": f"*Item:*\n{topic}"
                        },
                        {
                            "type": "mrkdwn",
                            "text": f"*New Status:*\n{status}"
                        }
                    ]
                }
            ]
            
            if comment:
                blocks.append({
                    "type": "section",
                    "text": {
                        "type": "mrkdwn",
                        "text": f"*Comment:*\n{comment}"
                    }
                })
            
            # Send the status update
            response = await self.async_client.chat_postMessage(
                channel=channel,
                text=f"Status Update: {topic} is now {status}",
                blocks=blocks
            )
            
            # Notify specific person if requested
            notification = None
            if notify_person:
                try:
                    notification_response = await self.async_client.chat_postMessage(
                        channel=notify_person,
                        text=f"Status Update: {topic} is now {status}",
                        blocks=blocks
                    )
                    notification = {
                        "person": notify_person,
                        "message_ts": notification_response["ts"]
                    }
                except SlackApiError as e:
                    logger.warning(f"Failed to notify {notify_person}: {e}")
            
            return {
                "success": True,
                "status_update": {
                    "topic": topic,
                    "status": status,
                    "comment": comment,
                    "channel": channel,
                    "message_ts": response["ts"],
                    "notification": notification
                },
                "timestamp": datetime.utcnow().isoformat()
            }
        except SlackApiError as e:
            logger.error(f"Slack API error: {e}")
            return {
                "success": False,
                "error": f"Slack API error: {e.response['error']}",
                "timestamp": datetime.utcnow().isoformat()
            }
        except Exception as e:
            logger.exception(f"Error updating status: {e}")
            return {
                "success": False,
                "error": str(e),
                "timestamp": datetime.utcnow().isoformat()
            }
    {% else %}
    async def execute_generic_action(self, params: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute a generic Slack action.
        
        Args:
            params: Action parameters
            
        Returns:
            Dict[str, Any]: Result of the action
        """
        try:
            # Extract parameters
            action_type = params.get("action_type", "message")
            channel = params.get("channel", TARGET_CHANNEL)
            text = params.get("text", f"Executing {INTENT} action")
            
            # Execute the appropriate action based on the action_type
            if action_type == "message":
                response = await self.async_client.chat_postMessage(
                    channel=channel,
                    text=text
                )
                
                return {
                    "success": True,
                    "action": {
                        "type": action_type,
                        "channel": channel,
                        "text": text,
                        "message_ts": response["ts"]
                    },
                    "timestamp": datetime.utcnow().isoformat()
                }
            elif action_type == "reaction":
                emoji = params.get("emoji", "thumbsup")
                message_ts = params.get("message_ts")
                
                if not message_ts:
                    return {
                        "success": False,
                        "error": "message_ts is required for reaction actions",
                        "timestamp": datetime.utcnow().isoformat()
                    }
                
                response = await self.async_client.reactions_add(
                    channel=channel,
                    timestamp=message_ts,
                    name=emoji
                )
                
                return {
                    "success": True,
                    "action": {
                        "type": action_type,
                        "channel": channel,
                        "message_ts": message_ts,
                        "emoji": emoji
                    },
                    "timestamp": datetime.utcnow().isoformat()
                }
            else:
                return {
                    "success": False,
                    "error": f"Unsupported action_type: {action_type}",
                    "timestamp": datetime.utcnow().isoformat()
                }
        except SlackApiError as e:
            logger.error(f"Slack API error: {e}")
            return {
                "success": False,
                "error": f"Slack API error: {e.response['error']}",
                "timestamp": datetime.utcnow().isoformat()
            }
        except Exception as e:
            logger.exception(f"Error executing generic action: {e}")
            return {
                "success": False,
                "error": str(e),
                "timestamp": datetime.utcnow().isoformat()
            }
    {% endif %}

# Main function for AWS Lambda
def lambda_handler(event, context):
    """
    AWS Lambda handler function.
    
    Args:
        event: The event dict containing action parameters
        context: The Lambda context object
        
    Returns:
        Dict containing the action result
    """
    import asyncio
    
    logger.info(f"Received event: {json.dumps(event)}")
    
    try:
        # Extract action parameters
        params = event.get("parameters", {})
        
        # Initialize the action executor
        action = SlackAction()
        
        # Execute the action
        result = asyncio.run(action.execute_action(params))
        
        # Return the result
        return {
            "statusCode": 200 if result.get("success", False) else 500,
            "body": json.dumps(result),
            "headers": {
                "Content-Type": "application/json"
            }
        }
    except Exception as e:
        logger.exception(f"Error processing Lambda event: {e}")
        return {
            "statusCode": 500,
            "body": json.dumps({
                "success": False,
                "error": str(e),
                "timestamp": datetime.utcnow().isoformat()
            }),
            "headers": {
                "Content-Type": "application/json"
            }
        }

# For local testing
if __name__ == "__main__":
    # Set up console logging
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)
    
    # Create an action executor
    action = SlackAction()
    
    # Example parameters for testing
    test_params = {
        {% if plan.intent == "create_task" %}
        "topic": "Example task",
        "description": "This is a test task",
        "date": "tomorrow",
        "priority": "high"
        {% elif plan.intent == "schedule_meeting" %}
        "topic": "Example meeting",
        "date": "2023-12-01",
        "time": "14:00",
        "duration": "60 minutes",
        "location": "Conference Room A",
        "description": "Discuss project status"
        {% elif plan.intent == "find_information" %}
        "topic": "project status",
        "channel": "general"
        {% elif plan.intent == "send_message" %}
        "person": "general",
        "content": "This is a test message"
        {% elif plan.intent == "update_status" %}
        "topic": "Project Alpha",
        "status": "In Progress",
        "comment": "Moving forward with implementation phase"
        {% else %}
        "action_type": "message",
        "channel": "general",
        "text": "This is a test message for {{ plan.intent }}"
        {% endif %}
    }
    
    # Execute the action
    import asyncio
    result = asyncio.run(action.execute_action(test_params))
    
    # Print the result
    print(json.dumps(result, indent=2))
