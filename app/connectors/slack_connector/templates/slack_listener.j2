"""
Slack Event Listener for {{ plan.intent }} Intent

This module was auto-generated by the Meta-Agent to handle Slack events related to the {{ plan.intent }} intent.
It listens for specific Slack events and processes them according to the defined workflow.

Generated for Goal: {{ plan.goal_id }}
Created at: {{ plan.created_at }}
"""

import json
import logging
import os
import re
import time
from typing import Dict, Any, Optional, List, Union, Callable, Awaitable
from datetime import datetime

import slack_sdk
from slack_sdk import WebClient
from slack_sdk.errors import SlackApiError
from slack_sdk.web.async_client import AsyncWebClient

# Set up logging
logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

# Constants
INTENT = "{{ plan.intent }}"
GOAL_ID = "{{ plan.goal_id }}"
STEP_ID = "{{ step.id }}"
ACTION_TYPE = "{{ step.action_type }}"

# Configuration
SLACK_TOKEN = os.environ.get("SLACK_API_TOKEN", "{{ config.slack_api_token }}")
{% if parameters.get("channel") %}
TARGET_CHANNEL = "{{ parameters.get('channel') }}"
{% else %}
TARGET_CHANNEL = os.environ.get("SLACK_CHANNEL", "general")
{% endif %}
{% if parameters.get("keywords") %}
KEYWORDS = {{ parameters.get('keywords', [])|tojson }}
{% else %}
KEYWORDS = []
{% endif %}

class SlackEventListener:
    """
    Slack Event Listener for handling events related to {{ plan.intent }}.
    
    This class provides methods for processing various Slack events and
    taking appropriate actions based on the {{ plan.intent }} intent.
    """
    
    def __init__(self, token: str = SLACK_TOKEN):
        """
        Initialize the Slack Event Listener.
        
        Args:
            token: Slack API token
        """
        self.token = token
        self.client = WebClient(token=token)
        self.async_client = AsyncWebClient(token=token)
        self._event_handlers = {}
        
        # Register default event handlers
        self.register_handlers()
        
        logger.info(f"Initialized Slack Event Listener for {INTENT} intent")
    
    def register_handlers(self):
        """Register event handlers for different event types."""
        # Register handlers based on intent type
        {% if plan.intent == "create_task" %}
        self.register_handler("message", self.handle_task_message)
        self.register_handler("app_mention", self.handle_app_mention)
        {% elif plan.intent == "schedule_meeting" %}
        self.register_handler("message", self.handle_meeting_message)
        self.register_handler("app_mention", self.handle_app_mention)
        {% elif plan.intent == "find_information" %}
        self.register_handler("message", self.handle_search_message)
        self.register_handler("app_mention", self.handle_app_mention)
        {% elif plan.intent == "send_message" %}
        self.register_handler("message", self.handle_message_request)
        self.register_handler("app_mention", self.handle_app_mention)
        {% elif plan.intent == "update_status" %}
        self.register_handler("message", self.handle_status_update)
        self.register_handler("app_mention", self.handle_app_mention)
        {% else %}
        self.register_handler("message", self.handle_generic_message)
        self.register_handler("app_mention", self.handle_app_mention)
        {% endif %}
        
        # Register handlers for interactive components
        self.register_handler("block_actions", self.handle_block_actions)
        self.register_handler("view_submission", self.handle_view_submission)
    
    def register_handler(self, event_type: str, handler: Callable):
        """
        Register a handler for a specific event type.
        
        Args:
            event_type: Type of event to handle
            handler: Handler function
        """
        if event_type not in self._event_handlers:
            self._event_handlers[event_type] = []
        self._event_handlers[event_type].append(handler)
        logger.info(f"Registered handler for event type: {event_type}")
    
    async def process_event(self, event_type: str, event_data: Dict[str, Any]) -> None:
        """
        Process a Slack event.
        
        Args:
            event_type: Type of event
            event_data: Event data
        """
        try:
            # Check if we have handlers for this event type
            handlers = self._event_handlers.get(event_type, [])
            
            if handlers:
                # Call each registered handler
                for handler in handlers:
                    await handler(event_data)
            else:
                logger.info(f"No handler registered for event type: {event_type}")
        except Exception as e:
            logger.exception(f"Error processing event: {e}")
    
    # Event handlers
    
    async def handle_app_mention(self, event_data: Dict[str, Any]) -> None:
        """
        Handle app_mention events.
        
        Args:
            event_data: Event data
        """
        try:
            # Extract relevant information
            user = event_data.get("user")
            text = event_data.get("text", "")
            channel = event_data.get("channel")
            ts = event_data.get("ts")
            
            # Remove the bot mention from the text
            cleaned_text = re.sub(r"<@[A-Z0-9]+>", "", text).strip()
            
            logger.info(f"Received app_mention from {user}: {cleaned_text}")
            
            {% if plan.intent == "create_task" %}
            # Check if the message is about creating a task
            if any(keyword in cleaned_text.lower() for keyword in ["task", "todo", "reminder", "create"]):
                await self.create_task_from_message(cleaned_text, channel, ts, user)
            else:
                await self.send_help_message(channel, ts)
            {% elif plan.intent == "schedule_meeting" %}
            # Check if the message is about scheduling a meeting
            if any(keyword in cleaned_text.lower() for keyword in ["meeting", "schedule", "calendar", "appointment"]):
                await self.schedule_meeting_from_message(cleaned_text, channel, ts, user)
            else:
                await self.send_help_message(channel, ts)
            {% elif plan.intent == "find_information" %}
            # Check if the message is about finding information
            if any(keyword in cleaned_text.lower() for keyword in ["find", "search", "lookup", "information", "where"]):
                await self.search_information(cleaned_text, channel, ts, user)
            else:
                await self.send_help_message(channel, ts)
            {% elif plan.intent == "send_message" %}
            # Check if the message is about sending a message
            if any(keyword in cleaned_text.lower() for keyword in ["send", "message", "tell", "notify"]):
                await self.process_message_request(cleaned_text, channel, ts, user)
            else:
                await self.send_help_message(channel, ts)
            {% elif plan.intent == "update_status" %}
            # Check if the message is about updating status
            if any(keyword in cleaned_text.lower() for keyword in ["status", "update", "change", "progress"]):
                await self.process_status_update(cleaned_text, channel, ts, user)
            else:
                await self.send_help_message(channel, ts)
            {% else %}
            # Generic intent handling
            await self.process_generic_intent(cleaned_text, channel, ts, user)
            {% endif %}
        except Exception as e:
            logger.exception(f"Error handling app_mention: {e}")
    
    {% if plan.intent == "create_task" %}
    async def handle_task_message(self, event_data: Dict[str, Any]) -> None:
        """
        Handle messages related to task creation.
        
        Args:
            event_data: Event data
        """
        # Skip bot messages and message_changed events
        if event_data.get("bot_id") or event_data.get("subtype"):
            return
        
        try:
            # Extract relevant information
            user = event_data.get("user")
            text = event_data.get("text", "")
            channel = event_data.get("channel")
            ts = event_data.get("ts")
            
            # Only process direct messages or messages in the target channel
            is_dm = channel.startswith("D")
            is_target_channel = channel == TARGET_CHANNEL
            
            if not (is_dm or is_target_channel):
                return
            
            # Check if the message is about creating a task
            if any(keyword in text.lower() for keyword in ["task", "todo", "reminder", "create"]):
                await self.create_task_from_message(text, channel, ts, user)
        except Exception as e:
            logger.exception(f"Error handling task message: {e}")
    
    async def create_task_from_message(self, text: str, channel: str, ts: str, user: str) -> None:
        """
        Create a task from a message.
        
        Args:
            text: Message text
            channel: Channel ID
            ts: Message timestamp
            user: User ID
        """
        try:
            # Extract task details from the message
            # This is a simple implementation; in a real system, you would use NLP
            task_title = text.split("\n")[0] if "\n" in text else text
            
            # Create a simple task object
            task = {
                "title": task_title,
                "created_by": user,
                "created_at": datetime.utcnow().isoformat(),
                "status": "pending"
            }
            
            # In a real implementation, you would store the task in a database
            logger.info(f"Created task: {task['title']}")
            
            # Send a confirmation message
            await self.async_client.chat_postMessage(
                channel=channel,
                text=f"I've created a task: *{task['title']}*",
                thread_ts=ts
            )
        except Exception as e:
            logger.exception(f"Error creating task: {e}")
            await self.async_client.chat_postMessage(
                channel=channel,
                text=f"Sorry, I couldn't create the task: {str(e)}",
                thread_ts=ts
            )
    {% elif plan.intent == "schedule_meeting" %}
    async def handle_meeting_message(self, event_data: Dict[str, Any]) -> None:
        """
        Handle messages related to meeting scheduling.
        
        Args:
            event_data: Event data
        """
        # Skip bot messages and message_changed events
        if event_data.get("bot_id") or event_data.get("subtype"):
            return
        
        try:
            # Extract relevant information
            user = event_data.get("user")
            text = event_data.get("text", "")
            channel = event_data.get("channel")
            ts = event_data.get("ts")
            
            # Only process direct messages or messages in the target channel
            is_dm = channel.startswith("D")
            is_target_channel = channel == TARGET_CHANNEL
            
            if not (is_dm or is_target_channel):
                return
            
            # Check if the message is about scheduling a meeting
            if any(keyword in text.lower() for keyword in ["meeting", "schedule", "calendar", "appointment"]):
                await self.schedule_meeting_from_message(text, channel, ts, user)
        except Exception as e:
            logger.exception(f"Error handling meeting message: {e}")
    
    async def schedule_meeting_from_message(self, text: str, channel: str, ts: str, user: str) -> None:
        """
        Schedule a meeting from a message.
        
        Args:
            text: Message text
            channel: Channel ID
            ts: Message timestamp
            user: User ID
        """
        try:
            # Extract meeting details from the message
            # This is a simple implementation; in a real system, you would use NLP
            meeting_title = text.split("\n")[0] if "\n" in text else text
            
            # Create a simple meeting object
            meeting = {
                "title": meeting_title,
                "organizer": user,
                "created_at": datetime.utcnow().isoformat(),
                "status": "scheduled"
            }
            
            # In a real implementation, you would store the meeting in a calendar
            logger.info(f"Scheduled meeting: {meeting['title']}")
            
            # Send a confirmation message
            await self.async_client.chat_postMessage(
                channel=channel,
                text=f"I've scheduled a meeting: *{meeting['title']}*",
                thread_ts=ts
            )
        except Exception as e:
            logger.exception(f"Error scheduling meeting: {e}")
            await self.async_client.chat_postMessage(
                channel=channel,
                text=f"Sorry, I couldn't schedule the meeting: {str(e)}",
                thread_ts=ts
            )
    {% elif plan.intent == "find_information" %}
    async def handle_search_message(self, event_data: Dict[str, Any]) -> None:
        """
        Handle messages related to information search.
        
        Args:
            event_data: Event data
        """
        # Skip bot messages and message_changed events
        if event_data.get("bot_id") or event_data.get("subtype"):
            return
        
        try:
            # Extract relevant information
            user = event_data.get("user")
            text = event_data.get("text", "")
            channel = event_data.get("channel")
            ts = event_data.get("ts")
            
            # Only process direct messages or messages in the target channel
            is_dm = channel.startswith("D")
            is_target_channel = channel == TARGET_CHANNEL
            
            if not (is_dm or is_target_channel):
                return
            
            # Check if the message is about finding information
            if any(keyword in text.lower() for keyword in ["find", "search", "lookup", "information", "where"]):
                await self.search_information(text, channel, ts, user)
        except Exception as e:
            logger.exception(f"Error handling search message: {e}")
    
    async def search_information(self, text: str, channel: str, ts: str, user: str) -> None:
        """
        Search for information based on a message.
        
        Args:
            text: Message text
            channel: Channel ID
            ts: Message timestamp
            user: User ID
        """
        try:
            # Extract search query from the message
            # This is a simple implementation; in a real system, you would use NLP
            search_query = text.replace("find", "").replace("search", "").replace("lookup", "").replace("information", "").replace("where", "").strip()
            
            # In a real implementation, you would perform an actual search
            logger.info(f"Searching for: {search_query}")
            
            # Send a response message
            await self.async_client.chat_postMessage(
                channel=channel,
                text=f"I'm searching for information about: *{search_query}*\n\nHere are some example results:\n• Example result 1\n• Example result 2",
                thread_ts=ts
            )
        except Exception as e:
            logger.exception(f"Error searching information: {e}")
            await self.async_client.chat_postMessage(
                channel=channel,
                text=f"Sorry, I couldn't find that information: {str(e)}",
                thread_ts=ts
            )
    {% elif plan.intent == "send_message" %}
    async def handle_message_request(self, event_data: Dict[str, Any]) -> None:
        """
        Handle messages related to sending messages.
        
        Args:
            event_data: Event data
        """
        # Skip bot messages and message_changed events
        if event_data.get("bot_id") or event_data.get("subtype"):
            return
        
        try:
            # Extract relevant information
            user = event_data.get("user")
            text = event_data.get("text", "")
            channel = event_data.get("channel")
            ts = event_data.get("ts")
            
            # Only process direct messages or messages in the target channel
            is_dm = channel.startswith("D")
            is_target_channel = channel == TARGET_CHANNEL
            
            if not (is_dm or is_target_channel):
                return
            
            # Check if the message is about sending a message
            if any(keyword in text.lower() for keyword in ["send", "message", "tell", "notify"]):
                await self.process_message_request(text, channel, ts, user)
        except Exception as e:
            logger.exception(f"Error handling message request: {e}")
    
    async def process_message_request(self, text: str, channel: str, ts: str, user: str) -> None:
        """
        Process a request to send a message.
        
        Args:
            text: Message text
            channel: Channel ID
            ts: Message timestamp
            user: User ID
        """
        try:
            # Extract message details from the request
            # This is a simple implementation; in a real system, you would use NLP
            parts = text.split(" to ", 1)
            if len(parts) < 2:
                await self.async_client.chat_postMessage(
                    channel=channel,
                    text="I need to know who to send the message to. Please use the format: 'send [message] to [recipient]'",
                    thread_ts=ts
                )
                return
            
            message_content = parts[0].replace("send", "").replace("message", "").replace("tell", "").replace("notify", "").strip()
            recipient = parts[1].strip()
            
            # In a real implementation, you would send the actual message
            logger.info(f"Sending message to {recipient}: {message_content}")
            
            # Send a confirmation message
            await self.async_client.chat_postMessage(
                channel=channel,
                text=f"I've sent your message to *{recipient}*:\n\n>{message_content}",
                thread_ts=ts
            )
        except Exception as e:
            logger.exception(f"Error processing message request: {e}")
            await self.async_client.chat_postMessage(
                channel=channel,
                text=f"Sorry, I couldn't send that message: {str(e)}",
                thread_ts=ts
            )
    {% elif plan.intent == "update_status" %}
    async def handle_status_update(self, event_data: Dict[str, Any]) -> None:
        """
        Handle messages related to status updates.
        
        Args:
            event_data: Event data
        """
        # Skip bot messages and message_changed events
        if event_data.get("bot_id") or event_data.get("subtype"):
            return
        
        try:
            # Extract relevant information
            user = event_data.get("user")
            text = event_data.get("text", "")
            channel = event_data.get("channel")
            ts = event_data.get("ts")
            
            # Only process direct messages or messages in the target channel
            is_dm = channel.startswith("D")
            is_target_channel = channel == TARGET_CHANNEL
            
            if not (is_dm or is_target_channel):
                return
            
            # Check if the message is about updating status
            if any(keyword in text.lower() for keyword in ["status", "update", "change", "progress"]):
                await self.process_status_update(text, channel, ts, user)
        except Exception as e:
            logger.exception(f"Error handling status update: {e}")
    
    async def process_status_update(self, text: str, channel: str, ts: str, user: str) -> None:
        """
        Process a status update request.
        
        Args:
            text: Message text
            channel: Channel ID
            ts: Message timestamp
            user: User ID
        """
        try:
            # Extract status details from the request
            # This is a simple implementation; in a real system, you would use NLP
            parts = text.split(" to ", 1)
            if len(parts) < 2:
                await self.async_client.chat_postMessage(
                    channel=channel,
                    text="I need to know the new status. Please use the format: 'update [item] to [status]'",
                    thread_ts=ts
                )
                return
            
            item = parts[0].replace("update", "").replace("status", "").replace("change", "").replace("progress", "").strip()
            new_status = parts[1].strip()
            
            # In a real implementation, you would update the actual status
            logger.info(f"Updating status of {item} to {new_status}")
            
            # Send a confirmation message
            await self.async_client.chat_postMessage(
                channel=channel,
                text=f"I've updated the status of *{item}* to *{new_status}*",
                thread_ts=ts
            )
        except Exception as e:
            logger.exception(f"Error processing status update: {e}")
            await self.async_client.chat_postMessage(
                channel=channel,
                text=f"Sorry, I couldn't update that status: {str(e)}",
                thread_ts=ts
            )
    {% else %}
    async def handle_generic_message(self, event_data: Dict[str, Any]) -> None:
        """
        Handle generic messages.
        
        Args:
            event_data: Event data
        """
        # Skip bot messages and message_changed events
        if event_data.get("bot_id") or event_data.get("subtype"):
            return
        
        try:
            # Extract relevant information
            user = event_data.get("user")
            text = event_data.get("text", "")
            channel = event_data.get("channel")
            ts = event_data.get("ts")
            
            # Only process direct messages or messages in the target channel
            is_dm = channel.startswith("D")
            is_target_channel = channel == TARGET_CHANNEL
            
            if not (is_dm or is_target_channel):
                return
            
            # Check if the message contains any keywords
            if KEYWORDS and any(keyword in text.lower() for keyword in KEYWORDS):
                await self.process_generic_intent(text, channel, ts, user)
        except Exception as e:
            logger.exception(f"Error handling generic message: {e}")
    
    async def process_generic_intent(self, text: str, channel: str, ts: str, user: str) -> None:
        """
        Process a generic intent.
        
        Args:
            text: Message text
            channel: Channel ID
            ts: Message timestamp
            user: User ID
        """
        try:
            # In a real implementation, you would process the intent based on the message
            logger.info(f"Processing generic intent for message: {text}")
            
            # Send a response message
            await self.async_client.chat_postMessage(
                channel=channel,
                text=f"I received your message about *{INTENT}*. I'm processing it now.",
                thread_ts=ts
            )
        except Exception as e:
            logger.exception(f"Error processing generic intent: {e}")
            await self.async_client.chat_postMessage(
                channel=channel,
                text=f"Sorry, I couldn't process your request: {str(e)}",
                thread_ts=ts
            )
    {% endif %}
    
    async def handle_block_actions(self, event_data: Dict[str, Any]) -> None:
        """
        Handle block_actions interactions.
        
        Args:
            event_data: Event data
        """
        try:
            # Extract relevant information
            user = event_data.get("user", {}).get("id")
            actions = event_data.get("actions", [])
            channel = event_data.get("channel", {}).get("id")
            response_url = event_data.get("response_url")
            
            for action in actions:
                action_id = action.get("action_id")
                action_value = action.get("value")
                
                logger.info(f"Received block action: {action_id} with value: {action_value}")
                
                # Handle specific actions based on action_id
                if action_id.startswith("{{ plan.intent }}_"):
                    # Process the action
                    await self.process_block_action(action_id, action_value, user, channel, response_url)
        except Exception as e:
            logger.exception(f"Error handling block actions: {e}")
    
    async def handle_view_submission(self, event_data: Dict[str, Any]) -> None:
        """
        Handle view_submission interactions.
        
        Args:
            event_data: Event data
        """
        try:
            # Extract relevant information
            user = event_data.get("user", {}).get("id")
            view = event_data.get("view", {})
            view_id = view.get("id")
            callback_id = view.get("callback_id")
            state = view.get("state", {}).get("values", {})
            
            logger.info(f"Received view submission for view: {view_id} with callback_id: {callback_id}")
            
            # Process form values
            form_values = {}
            for block_id, block_data in state.items():
                for action_id, action_data in block_data.items():
                    # Different action types have different value formats
                    if "value" in action_data:
                        form_values[action_id] = action_data["value"]
                    elif "selected_option" in action_data:
                        form_values[action_id] = action_data["selected_option"]["value"]
                    elif "selected_options" in action_data:
                        form_values[action_id] = [option["value"] for option in action_data["selected_options"]]
                    elif "selected_date" in action_data:
                        form_values[action_id] = action_data["selected_date"]
            
            # Handle the form submission based on the callback_id
            if callback_id.startswith("{{ plan.intent }}_"):
                await self.process_view_submission(callback_id, form_values, user)
        except Exception as e:
            logger.exception(f"Error handling view submission: {e}")
    
    async def process_block_action(
        self, action_id: str, action_value: str, user: str, channel: str, response_url: Optional[str]
    ) -> None:
        """
        Process a block action.
        
        Args:
            action_id: ID of the action
            action_value: Value of the action
            user: User ID
            channel: Channel ID
            response_url: Response URL for updating the message
        """
        # This method would be customized based on the specific actions needed for the intent
        logger.info(f"Processing block action: {action_id}")
        
        # Example implementation
        try:
            # Send a confirmation message
            await self.async_client.chat_postMessage(
                channel=channel,
                text=f"Action processed: {action_id} with value: {action_value}"
            )
        except Exception as e:
            logger.exception(f"Error processing block action: {e}")
    
    async def process_view_submission(
        self, callback_id: str, form_values: Dict[str, Any], user: str
    ) -> None:
        """
        Process a view submission.
        
        Args:
            callback_id: Callback ID of the view
            form_values: Form values from the view
            user: User ID
        """
        # This method would be customized based on the specific forms needed for the intent
        logger.info(f"Processing view submission: {callback_id}")
        
        # Example implementation
        try:
            # Send a confirmation message
            await self.async_client.chat_postMessage(
                channel=user,  # DM to the user
                text=f"Form submitted: {callback_id}\n\nValues: {json.dumps(form_values, indent=2)}"
            )
        except Exception as e:
            logger.exception(f"Error processing view submission: {e}")
    
    async def send_help_message(self, channel: str, thread_ts: Optional[str] = None) -> None:
        """
        Send a help message.
        
        Args:
            channel: Channel ID
            thread_ts: Thread timestamp for replying in a thread
        """
        try:
            {% if plan.intent == "create_task" %}
            help_text = (
                "I can help you create tasks. Try saying:\n"
                "• Create a task to review the proposal\n"
                "• Add a reminder to follow up with the client\n"
                "• New todo: prepare presentation for tomorrow"
            )
            {% elif plan.intent == "schedule_meeting" %}
            help_text = (
                "I can help you schedule meetings. Try saying:\n"
                "• Schedule a meeting for tomorrow at 2pm\n"
                "• Set up a call with the team on Friday\n"
                "• Create a calendar event for the project review"
            )
            {% elif plan.intent == "find_information" %}
            help_text = (
                "I can help you find information. Try saying:\n"
                "• Find information about the quarterly report\n"
                "• Search for the latest marketing materials\n"
                "• Look up the project timeline"
            )
            {% elif plan.intent == "send_message" %}
            help_text = (
                "I can help you send messages. Try saying:\n"
                "• Send a message to John about the meeting\n"
                "• Tell the team we need to reschedule\n"
                "• Notify marketing about the campaign launch"
            )
            {% elif plan.intent == "update_status" %}
            help_text = (
                "I can help you update statuses. Try saying:\n"
                "• Update the project status to in progress\n"
                "• Change the ticket status to resolved\n"
                "• Set the task status to completed"
            )
            {% else %}
            help_text = (
                "I can help you with various tasks related to {{ plan.intent }}. Try asking me to do something specific."
            )
            {% endif %}
            
            await self.async_client.chat_postMessage(
                channel=channel,
                text=help_text,
                thread_ts=thread_ts
            )
        except Exception as e:
            logger.exception(f"Error sending help message: {e}")

# Main function for AWS Lambda
def lambda_handler(event, context):
    """
    AWS Lambda handler function.
    
    Args:
        event: The event dict containing the Slack event
        context: The Lambda context object
        
    Returns:
        Dict containing the response
    """
    import asyncio
    
    logger.info(f"Received event: {json.dumps(event)}")
    
    try:
        # Extract the Slack event
        body = event.get("body")
        if not body:
            return {
                "statusCode": 400,
                "body": json.dumps({"error": "No body in the request"})
            }
        
        # Parse the body if it's a string
        if isinstance(body, str):
            body = json.loads(body)
        
        # Handle URL verification
        if body.get("type") == "url_verification":
            logger.info("Handling Slack URL verification")
            return {
                "statusCode": 200,
                "body": json.dumps({"challenge": body.get("challenge")})
            }
        
        # Handle events
        if body.get("type") == "event_callback":
            event_data = body.get("event", {})
            event_type = event_data.get("type")
            
            if event_type:
                logger.info(f"Processing Slack event: {event_type}")
                
                # Initialize the event listener
                listener = SlackEventListener()
                
                # Process the event
                asyncio.run(listener.process_event(event_type, event_data))
        
        # Return a 200 OK response
        return {
            "statusCode": 200,
            "body": json.dumps({"status": "ok"})
        }
    except Exception as e:
        logger.exception(f"Error processing Lambda event: {e}")
        return {
            "statusCode": 500,
            "body": json.dumps({"error": str(e)})
        }

# For local testing
if __name__ == "__main__":
    # Set up console logging
    console_handler = logging.StreamHandler()
    console_handler.setLevel(logging.INFO)
    formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    console_handler.setFormatter(formatter)
    logger.addHandler(console_handler)
    
    # Create an event listener
    listener = SlackEventListener()
    
    # Example event for testing
    test_event = {
        "type": "event_callback",
        "event": {
            "type": "app_mention",
            "user": "U12345678",
            "text": "<@U87654321> {{ plan.intent }}",
            "channel": "C12345678",
            "ts": "1234567890.123456"
        }
    }
    
    # Process the test event
    asyncio.run(listener.process_event(test_event["event"]["type"], test_event["event"]))
